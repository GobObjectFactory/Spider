- prefer composite moves that create a free cell, particularly after a deal
- prefer last resort moves that lead to a discard
- optimize scoring factors using designed experiments
- make console access threadsafe
- before playing onto a free cell search for a free cell preserving sequence

- improve scoring of offload moves
- consider enumerating all offload moves instead of one per pile
- match suit and face for offload moves
- convert lower stack into yet another root
- permit inner run to be the offload
- count homeless runs allowing them as long as free cells permit
- no homeless at the end makes an emptying move
- no homeless anywhere else makes a free-cell preserving move
- one homeless at the end makes a free-cell perserving move
- use SupplementaryMoves instead of local list moves
- intermediate offload runs could use holding piles as well
- for offload consider trying to find homes for homeless runs by moving piles

- convert last resort scoring to new model

- add basic unit tests
- add holding unit tests

- inverted offload moves don't need to move the entire lower run to a free cell if the suits match
- offload moves no longer need the offload pile or offload index information

- prefer long exposed runs even if it means splitting a run

- figure out why simple consistently gets better results than complex
- theory: prefer to have a single run on a free cell
- calculate oneRunDelta correctly for swaps
- check whether moves with oneRunDelta > 0 are rejected

- alternate Nelder-Mead implementation:
  http://www.koders.com/csharp/fid218B2E3946027CB5037676EA50CE549B6FC26CF7.aspx?s=mdef:search

Coefficients = new double[] {
    /* 0 */ 7.792380919, 48.7750914, 666.6666667, -0.1895897457, -4.33729671, -0
.7892200528, 7.984789509,
    /* 7 */ 2.151250994, 0.004377244445, -0.1725631349, -0.6357675859,
};



spider --games 1 --seed 39983 --simple --suits 4
spider: seed: 39983, message: maximum moves exceeded
