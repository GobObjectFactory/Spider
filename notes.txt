- prefer last resort moves that lead to a discard
- optimize scoring factors using designed experiments
- before playing onto a free cell search for a free cell preserving sequence

- prefer holding moves that match suit

- could use holding piles for uncovering moves
- finish converting test jig to mstest
- ordinary moves and swaps could also count uses for the exposed card, if not consecutive
- rename test jig
- add unit tests for composite single pile moves with interior runs to holding piles
- add units tests for swap with reverse holding piles
- retest complex
- avoid spurious composite single pile moves due to uncovering
- merge the multiple different places that free cell algorithms are implemented
- move utility calculations like run length into supporting data structures
- separate analyze into analyze free cells and analyze runs
- forward swaps might be able to find different holding piles that wouldn't conflict with the to pile
- reverse swaps could use forward swap holding piles if we built an accurate card map
- convert holding list to use supplementary list instead
- improve scoring of offload moves
- consider enumerating all offload moves instead of one per pile
- for offload consider trying to find homes for homeless runs by uncovering targets

- inverted offload moves don't need to move the entire lower run to a free cell if the suits match

- prefer long exposed runs even if it means splitting a run, just before a deal

- figure out why simple consistently gets better results than complex
- theory: prefer to have a single run on a free cell
- calculate oneRunDelta correctly for swaps
- check whether moves with oneRunDelta > 0 are rejected

- alternate Nelder-Mead implementation:
  http://www.koders.com/csharp/fid218B2E3946027CB5037676EA50CE549B6FC26CF7.aspx?s=mdef:search
